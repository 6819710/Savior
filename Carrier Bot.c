#pragma config(Sensor, S1,     backSensor,     sensorEV3_Ultrasonic)
#pragma config(Sensor, S4,     frontSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          beltBack,      tmotorEV3_Large, PIDControl, reversed, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
#pragma config(Motor,  motorD,          beltFront,     tmotorEV3_Large, PIDControl, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Configuration - Change these to fine tune.
	int drivingSpeed = 15;
	int drivingDuration = 1000;
	int waitingDuration = 2000; //Time to wait after sending out a bot
	int parkedDistance = 7; //distance which means there IS a car in the bay
	
//Variables
	int frontDistance = 0;
	int backDistance = 0;

//States
	bool nextCycleFront = false;
	bool nextCycleBack = false;
	bool frontBayFull = false;
	bool backBayFull = false;

//Stop driving
void stopMoving()
{

	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

//Moves Forward
void moveForward()
{
	setMotorSpeed(leftMotor, drivingSpeed);		//Set the leftMotor (motor1) to half power (50)
	setMotorSpeed(rightMotor, drivingSpeed);  //Set the rightMotor (motor6) to half power (50)
}

//Overload - for a duration
void moveForward(int duration)
{
	moveForward();
	sleep(duration);
	stopMoving();
}

//Moves Backwards
void moveBackward()
{
	setMotorSpeed(leftMotor, -drivingSpeed);		//Set the leftMotor (motor1) to half power (50)
	setMotorSpeed(rightMotor, -drivingSpeed);  //Set the rightMotor (motor6) to half power (50)
}

//Overload - for a duration
void moveBackward(int duration)
{
	moveBackward();
	sleep(duration);
	stopMoving();
}

//Sense if both the delivery Robots are present
void checkBays()
{
	
	if (frontDistance > parkedDistance)
	{
		frontBayFull = false;
		nextCycleFront = false;
	}
	else if ((frontDistance < parkedDistance) && !frontBayFull && !nextCycleFront)
	{
		frontBayFull = true;
	}
	
	
	if ((backDistance > parkedDistance))
	{
		backBayFull = false;
		nextCycleBack = false;
	}
	else if ((backDistance < parkedDistance) && !backBayFull && !nextCycleBack)
	{
		backBayFull = true;
	}
}


task main()
{
	//Infinite Loop
	while(true)
	{
		//update variables
		frontDistance = getUSDistance(frontSensor);
		backDistance = getUSDistance(backSensor);
		
		//check for drones
		checkBays();
		
		// Load front drone
		if (frontBayFull && nextCycleFront)
		{
			setMotorSpeed(beltFront, 20);
			sleep(1000);
			setMotorSpeed(beltFront, 0);
		}
		
		// Load Back Drone
		if (backBayFull && nextCycleBack)
		{
			setMotorSpeed(beltBack, 20);
			sleep(1000);
			setMotorSpeed(beltBack, 0);
		}
		
		// If both drones have returned, move carrier forward
		if ((frontBayFull && !nextCycleFront) && (backBayFull && !nextCycleBack))
		{
			sleep(waitingDuration);
			moveForward(drivingDuration);
			nextCycleFront = true;
			nextCycleBack = true;
		}
	}
}
