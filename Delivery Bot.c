#pragma config(Sensor, S1,     colorSensor,    sensorEV3_Color, modeEV3Color_Color)
#pragma config(Sensor, S2,     gyroscopeSensor,     sensorEV3_Gyro)
#pragma config(Sensor, S4,     sonarSensor,    sensorEV3_Ultrasonic)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorEV3_Medium, PIDControl, encoder)
#pragma config(Motor,  motorB,          leftMotor,     tmotorEV3_Large, PIDControl, driveLeft, encoder)
#pragma config(Motor,  motorC,          rightMotor,    tmotorEV3_Large, PIDControl, driveRight, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int gripperRange = 5;
int correctionRange = 8;
int errorMargin = 2;
int gripperSpeed = 50;
int drivingSpeed = 25;
int drivingDuration = 2500;
TLegoColors colorDetected = colorNone;

//Variables
int currentDistance = 0;
bool gripperOpen = true;
bool delivered = false;
bool correcting = false;
int correctionDuration = 0;

void stopMove()
{
	setMotorSpeed(leftMotor, 0);
	setMotorSpeed(rightMotor, 0);
}

void forwardMove()
{
	setMotorSpeed(leftMotor, drivingSpeed);
	setMotorSpeed(rightMotor, drivingSpeed);
}

void forwardMove(int duration)
{
	forwardMove();
	sleep(duration);
	stopMove();
}

void backwardMove()
{
	setMotorSpeed(leftMotor, -drivingSpeed);
	setMotorSpeed(rightMotor, -drivingSpeed);
}

void backwardMove(int duration)
{
	backwardMove();
	sleep(duration);
	stopMove();
}

void rotateClockwise(int angle)
{
	resetGyro(gyroscopeSensor);
	setMotorSpeed(leftMotor, -drivingSpeed);
	setMotorSpeed(rightMotor, drivingSpeed);
	while(getGyroDegrees(gyroscopeSensor) < angle){}
	stopMove();
}

void rotateAnticlockwise(int angle)
{
	resetGyro(gyroscopeSensor);
	setMotorSpeed(leftMotor, drivingSpeed);
	setMotorSpeed(rightMotor, -drivingSpeed);
	while(getGyroDegrees(gyroscopeSensor) > -angle){}
	stopMove();
}


void closeGripper()
{
	resetMotorEncoder(gripperMotor);
	setMotorSpeed(gripperMotor, -gripperSpeed);
	while (getMotorEncoder(gripperMotor) > -1500) {}
	setMotorSpeed(gripperMotor, 0);
	gripperOpen = false;
}

void openGripper()
{
	resetMotorEncoder(gripperMotor);
	setMotorSpeed(gripperMotor, gripperSpeed);
	while (getMotorEncoder(gripperMotor) < 1500) {}
	setMotorSpeed(gripperMotor, 0);
	gripperOpen = true;
}

task main()
{
	//Infinite Loop
	while(true)
	{
		// Read the sensor
		currentDistance = getUSDistance(sonarSensor);

		// Open gripper if delivered flag and gripper is closed.
		if(delivered && !gripperOpen)
		{
			openGripper();
		}

		// Stop Moving and Close Gripper if payload is detected in gripper range
		if(!delivered && gripperOpen && ((gripperRange - currentDistance) > 0))
		{
			if (correcting) // Set correction duration
			{
				correctionDuration = time1[T1];
				correcting = false;
			}
			stopMove();
			closeGripper();
		}

		// Move to payload if payload is detected outside of gripper range
		if(!delivered && gripperOpen && ((gripperRange - currentDistance) > -correctionRange))
		{
			if(!correcting) // Reset Timer if not currently correcing.
			{
				clearTimer(T1);
				correcting = true;
			}
			forwardMove();
		}

		// detect color if not delivered and grippers closed
		if(!delivered && !gripperOpen)
		{
			colorDetected = getColorName(colorSensor);
		}

		// deliver to red destination if color detected is set to red
		if(!delivered && !gripperOpen && (colorDetected == colorRed))
		{
			forwardMove(drivingDuration);
			rotateClockwise(90);
			forwardMove(drivingDuration);
			delivered = true;
		}

		// deliver to blue destination if color detected is set to blue
		if(!delivered && !gripperOpen && (colorDetected == colorBlue))
		{
			forwardMove(drivingDuration);
			delivered = true;
		}

		// deliver to yellow destination if color detected is set to yellow
		if(!delivered && !gripperOpen && (colorDetected == colorYellow))
		{
			forwardMove(drivingDuration);
			rotateAnticlockwise(90);
			forwardMove(drivingDuration);
			delivered = true;
		}

		// deliver to green destination if color detected is set to green
		if(!delivered && !gripperOpen && (colorDetected == colorGreen))
		{
			forwardMove(drivingDuration);
			rotateClockwise(90);
			forwardMove(drivingDuration);
			rotateAnticlockwise(90);
			forwardMove(drivingDuration);
			delivered = true;
		}

		//Handle object removed from gripper sights before collecting it
		if(!delivered && correcting &&(currentDistance > (gripperRange+correctionRange+errorMargin)))
		{
				playSoundFile("Error");
				correctionDuration = time1[T1];
				correcting = false;
				backwardMove(correctionDuration);
				currentDistance = 0;
				colorDetected = colorNone;
		}

		// return from red desination once delivered and jaws opened
		if(delivered && gripperOpen && (colorDetected == colorRed))
		{
			backwardMove(drivingDuration);
			rotateAnticlockwise(90);
			backwardMove(drivingDuration);
			backwardMove(correctionDuration);
			delivered = false;
			currentDistance = 0;
			colorDetected = colorNone;
		}

		// return from blue desination once delivered and jaws opened
		if(delivered && gripperOpen && (colorDetected == colorBlue))
		{
			backwardMove(drivingDuration);
			backwardMove(correctionDuration);
			delivered = false;
			currentDistance = 0;
			colorDetected = colorNone;
		}

		// return from yellow desination once delivered and jaws opened
		if(delivered && gripperOpen && (colorDetected == colorYellow))
		{
			backwardMove(drivingDuration);
			rotateClockwise(90);
			backwardMove(drivingDuration);
			backwardMove(correctionDuration);
			delivered = false;
			currentDistance = 0;
			colorDetected = colorNone;
		}

		// return from green desination once delivered and jaws opened
		if(delivered && gripperOpen && (colorDetected == colorGreen))
		{
			backwardMove(drivingDuration);
			rotateClockwise(90);
			backwardMove(drivingDuration);
			rotateAnticlockwise(90);
			backwardMove(drivingDuration);
			backwardMove(correctionDuration);
			delivered = false;
			currentDistance = 0;
			colorDetected = colorNone;
		}
	}
}
